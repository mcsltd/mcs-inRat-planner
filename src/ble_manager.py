import asyncioimport datetimeimport loggingimport timefrom uuid import UUIDfrom threading import Thread, Lockfrom PySide6.QtCore import QObject, Signalfrom bleak import BLEDevice, BleakScannerfrom constants import RecordStatus, ScheduleStatefrom device.inrat.constants import InRatDataRateEcg, EnabledChannels, ScaleAccelerometer, EventTypefrom device.inrat.inrat import InRatfrom device.inrat.structures import InRatSettingsfrom storage import Storagefrom structure import RecordingTaskData, RecordDatafrom tools.check_bluetooth import is_bluetooth_enabledlogger = logging.getLogger(__name__)# константы ограничения времениCONNECTION_TIMEOUT = 12SCAN_TIMEOUT = 0.5DEVICE_DISCOVERY_TIMEOUT = 60 # общее ограничение на время поиска, подключения к устройствуclass BleManager(QObject):    # главное окно    signal_record_result = Signal(object)    signal_schedule_state = Signal(UUID, object)    signal_device_error = Signal(UUID, str)    # сигналы для устройства    signal_start_acquisition = Signal(UUID)    signal_data_received = Signal(UUID, dict)    signal_stop_acquisition = Signal(UUID, float)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.is_running = False        self.storage = Storage()        self._max_connected_devices = 2 # по умолчанию        # соединение сигналами Storage и BLEManager        self.signal_start_acquisition.connect(self.storage.add_recording_task)        self.signal_data_received.connect(self.storage.accept_data)        self.signal_stop_acquisition.connect(self.storage.stop_recording_task)        self.storage.signal_success_save.connect(self.handle_success_record_result)        self._recording_tasks: list[RecordingTaskData] = []             # задачи для записи        self._connected_devices: dict[UUID, InRat] = {}       # словарь с подключенными устройствами        self._acquisition_tasks: dict[UUID, asyncio.Task] = {}          # запущенные задачи на получение данных        self._device_queues: dict[UUID, asyncio.Queue] = {}             # очередь для получения данных с устройства        self._pending_connections: set[UUID] = set()                     # id устройств в процессе подключения        # контроль выполняемых задач        self._active_tasks_count = 0        self._task_events: dict[UUID, asyncio.Event] = {}        # блокировки        self._tasks_lock = Lock()        self._devices_lock = Lock()        self._counters_lock = Lock()        self._work_thread: None | Thread  = None        self._async_loop: None | asyncio.AbstractEventLoop = None    @property    def max_connected_devices(self) -> int:        return self._max_connected_devices    def set_max_connected_devices(self, cnt_device: int):        """ Установление максимального количества подключаемых устройств """        logger.info(f"Изменено кол-во подключаемых устройств: {cnt_device}")        self._max_connected_devices = cnt_device    def get_device_status(self, device_id: UUID):        """ Узнать статус устройства """        with self._tasks_lock:            if device_id in self._task_events:  # устройство в очереди                return ScheduleState.IN_QUEUE.value        with self._devices_lock:            if device_id in self._pending_connections:  # идёт поиск устройства                return ScheduleState.CONNECTION.value            if device_id in self._acquisition_tasks:    # идёт получение данных от устройства                return ScheduleState.ACQUISITION.value            if device_id in self._connected_devices:                return ScheduleState.CONNECT.value        return ScheduleState.DISCONNECT.value    def start(self):        """ Запуск BLE менеджера для работы с устройствами """        if self.is_running:            logger.warning("BLE менеджер уже запущен")            return        self.is_running = True        self._work_thread = Thread(target=self._run_async_loop)        self._work_thread.start()        logger.info("BLE менеджер запущен")    def _run_async_loop(self):        """ Создание асинхронного цикла событий и запуск в нём цикла обработки """        self._async_loop = asyncio.new_event_loop()        asyncio.set_event_loop(self._async_loop)        self._async_loop.set_debug(True)        try:            self._async_loop.run_until_complete(self._processing_loop())        finally:            self._async_loop.close()    async def _processing_loop(self):        """        Главный цикл, в котором происходит обработка очереди из устройств.        Обработка включает в себя: 1) поиск; 2) соединение; 3) получение данных; 4) отключение        """        while self.is_running:            await self._process_new_task()     # обработка новых задач записи            await self._cleanup_expired_tasks() # очистка просроченных задач            await asyncio.sleep(0.1)    async def _cleanup_expired_tasks(self):        """ Очистка задач с просроченными временем выполнения """        task_to_remove: list[RecordingTaskData] = []        with self._tasks_lock:            # проверка очереди задач на истекщие            for idx, task in enumerate(self._recording_tasks):                current_time = datetime.datetime.now()                if current_time > task.start_time + datetime.timedelta(seconds=DEVICE_DISCOVERY_TIMEOUT):                    logger.warning(f"Просрочена задача для {task.device.ble_name}:\n"                                   f"   текущее время: {current_time.replace(microsecond=0)}\n"                                   f"   время начала выполнения задачи: {task.start_time}")                    task_to_remove.append(self._recording_tasks[idx])            # удаление истекших задач            for task in task_to_remove:                self._recording_tasks.remove(task)        # оповещение о том что запись не была сделана по расписанию        for task in task_to_remove:            self._process_task_failure(                task=task, error_message=f"Не удалось сделать запись для {task.device.ble_name} в {task.start_time.replace(microsecond=0)}.\n"                f"Причина: для устройства не хватило доступных слотов на запись.")    def _process_task_failure(self, task: RecordingTaskData, error_message: str):        """ Обработка задачи, которая не выполнилась """        record_data = task.get_result_record(start_time=task.start_time, status=RecordStatus.ERROR, duration=0)        self.signal_record_result.emit(record_data)        self.signal_schedule_state.emit(task.schedule_id, ScheduleState.DISCONNECT)        self.signal_device_error.emit(task.device.id, error_message)    async def _process_new_task(self) -> None:        """ Обработка новых задач на подключение с учетом лимитов на подключение """        with self._tasks_lock:            if len(self._recording_tasks) == 0: # проверка на отсутствие задач в очереди                return            recording_task = self._recording_tasks[0]            device_id = recording_task.device.id            schedule_id = recording_task.schedule_id            if (device_id in self._connected_devices or device_id in self._pending_connections                    or device_id in self._acquisition_tasks):                self._recording_tasks.pop(0) # удалить задачу для устройств                logger.warning(f"Устройство {recording_task.device.ble_name} уже подключено или в процессе подключения")                return        # проверить доступность слотов        if not await self._wait_for_available_slot(device_id=device_id, schedule_id=schedule_id):            return        # если слот доступен, запускаем подключение        with self._tasks_lock:            if self._recording_tasks and self._recording_tasks[0].device.id == device_id:                recording_task = self._recording_tasks.pop(0)                # запуск подключения и получения данных с устройства на фоне                asyncio.create_task(self._device_connect_and_data_acquisition(recording_task))    async def _increment_active_counter(self):        """ Увеличить счетчик активных задач """        with self._counters_lock:            self._active_tasks_count += 1            logger.debug(f"Активных задач: {self._active_tasks_count}/{self._max_connected_devices}")    async def _decrement_active_counter(self):        """ Уменьшить число активных задачи """        with self._counters_lock:            self._active_tasks_count -= 1            logger.debug(f"Уменьшено активных задач: {self._active_tasks_count}/{self._max_connected_devices}")        # Будим ожидающие задачи        for event in self._task_events.values():            event.set()        # Очищаем установленные события        self._task_events.clear()    async def _wait_for_available_slot(self, device_id: UUID, schedule_id: UUID) -> bool:        """ Ожидание доступного слота для подключения к устройству с device_id"""        with self._counters_lock:            current_count = self._active_tasks_count        if current_count < self._max_connected_devices:            return True        self.signal_schedule_state.emit(schedule_id, ScheduleState.IN_QUEUE)        if device_id not in self._task_events:            self._task_events[device_id] = asyncio.Event()        logger.info(f"Устройство {device_id} ожидает доступный слот. Активных задач: {current_count}/{self._max_connected_devices}")        try:            # ожидание освобождения слота с перерывом 1 секунда            await asyncio.wait_for(self._task_events[device_id].wait(), timeout=0.1)            return True        except asyncio.TimeoutError:            # проверка истекло ли время задачи            with self._tasks_lock:                for task in self._recording_tasks:                    if task.device.id == device_id:                        if datetime.datetime.now() >= task.start_time + datetime.timedelta(seconds=DEVICE_DISCOVERY_TIMEOUT):                            logger.warning(f"Устройство {device_id} не дождалось слота - истекло время")                            return False            return False    async def _device_connect_and_data_acquisition(self, task: RecordingTaskData):        """ Подключение к устройству и поддержание соединения """        device_id = task.device.id        device_name = task.device.ble_name        await self._increment_active_counter()  # увеличить счётчик выполняемых задач        self._pending_connections.add(device_id)    # добавить id устройств в список ожидающих подключения        self.signal_schedule_state.emit(task.schedule_id, ScheduleState.CONNECTION) # обновить состояние расписания в таблице        discovery_start_time = time.time()        while (self.is_running and device_id not in self._connected_devices and device_id in self._pending_connections               and time.time() - discovery_start_time < DEVICE_DISCOVERY_TIMEOUT        ):            try:                # поиск устройства                logger.info(f"Попытка подключения к устройству {device_name}")                ble_device = await self._find_device_by_name(device_name)                if ble_device is None:                    logger.debug(f"Устройство {device_name} не найдено")                    continue                if task.device.model == "inRat-1-":                    device = InRat(ble_device)                else:                    logger.error(f"Неизвестная модель - {task.device.model}")                    raise ValueError(f"Модель {task.device.model} не поддерживается!")                if await device.connect(CONNECTION_TIMEOUT):                    self.signal_schedule_state.emit(task.schedule_id, ScheduleState.CONNECT)                    logger.info(f"Успешное подключение к устройству {device_name}")                    # добавляем новое подключенное устройство                    with self._devices_lock:                        self._connected_devices[device_id] = device                    self._pending_connections.remove(device_id) # устройство подсоединено                    self._device_queues[device_id] = asyncio.Queue()                    # создание задачи на получение данных с устройства и добавление её в очередь                    with self._devices_lock:                        self._acquisition_tasks[device_id] = asyncio.create_task(self._start_data_acquisition(device, task))                else:                    logger.warning(f"Не удалось подключиться к устройству {device_name}")            except Exception as exc:                logger.error(f"Ошибка при подключении к {device_name}: {exc}")        if time.time() - discovery_start_time > DEVICE_DISCOVERY_TIMEOUT:            logger.warning(f"К устройству {device_name} не удалось подключиться.")            if device_id in self._pending_connections:                self._pending_connections.remove(device_id)            self.signal_device_error.emit(device_id, f"Не удалось найти устройство {task.device.ble_name}.")            record_data = task.get_result_record(start_time=task.start_time, duration=0, status=RecordStatus.ERROR)  # ошибка записи            self.signal_record_result.emit(record_data)            await self._decrement_active_counter()  # уменьшаем счётчик задач    async def _start_data_acquisition(self, device: InRat, task: RecordingTaskData):        """ Запуск сбора данных с устройства и их обработка """        device_id = task.device.id        acquisition_st = time.time()        self.signal_start_acquisition.emit(task)  # сигнал о начале записи        try:            # задание настроек в зависимости от модели устройства            sampling_rate = self.set_sampling_rate_in_rat(task.sampling_rate)            base_settings = InRatSettings(DataRateEcg=sampling_rate, HighPassFilterEcg=0,            FullScaleAccelerometer=ScaleAccelerometer.G_2.value, EnabledChannels=EnabledChannels.ECG,            EnabledEvents=EventType.START, ActivityThreshold=1)            data_queue = self._device_queues[device_id]            if await device.start_acquisition(settings=base_settings, data_queue=data_queue):                acquisition_st = time.time()                logger.info(f"Сбор данных запущен для устройства {task.device.ble_name}")                self.signal_schedule_state.emit(task.schedule_id,                    ScheduleState.ACQUISITION)  # извещение главного окна об изменении статуса расписания -> идёт запись ЭКГ                # обработка входящих данных                while self.is_running and device.is_connected and time.time() - acquisition_st < task.sec_duration:                    try:                        data = await asyncio.wait_for(data_queue.get(), timeout=1.0)                        self.signal_data_received.emit(device_id, data)                        data_queue.task_done()                    except asyncio.TimeoutError:                        continue                    except Exception as exp:                        logger.error(f"Ошибка обработки данных с устройства {task.device.ble_name}: {exp}")                        self.signal_stop_acquisition.emit(device_id, acquisition_st)                        break        except Exception as exc:            record_data = task.get_result_record(start_time=task.start_time, duration=0, status=RecordStatus.ERROR)  # ошибка записи            self.signal_record_result.emit(record_data)            logger.error(f"Ошибка в задаче сбора данных для {task.device.ble_name}: {exc}")        finally:            if not device.is_connected:   # извещение о потере соединения с устройством                self.signal_device_error.emit(                    device_id, f"Потеряно соединение с устройством {task.device.ble_name}.\nЗаписанный сигнал ЭКГ будет сохранен.")            self.signal_schedule_state.emit(task.schedule_id, ScheduleState.DISCONNECT)            self.signal_stop_acquisition.emit(device_id, acquisition_st)    # сигнал о конце записи            await self._cleanup_device(device_id)  # Очистка при завершении            await self._decrement_active_counter()    async def _cleanup_device(self, device_id: UUID):        """ Очистка ресурсов устройства """        logger.debug(f"Очистка ресурсов устройства с идентификатором {device_id}")        try:            with self._devices_lock:                # убрать device_id из словаря подключенных устройств                if device_id in self._connected_devices:                    device = self._connected_devices[device_id]                    if device.is_connected:                        await device.stop_acquisition()                        await device.disconnect()                        logger.debug(f"Остановлено получение данных с устройства с идентификатором: {device_id}")                    del self._connected_devices[device_id]                # отмена задачи на получение данных                if device_id in self._acquisition_tasks:                    logger.debug(f"Отменена задача на получение данных с устройства с идентификатором: {device_id}")                    self._acquisition_tasks[device_id].cancel()                    try:                        await self._acquisition_tasks[device_id]                    except asyncio.CancelledError:                        pass                    del self._acquisition_tasks[device_id]                # удаление очереди для устройства с device_id                if device_id in self._device_queues:                    self._device_queues.pop(device_id)                logger.info(f"Ресурсы устройства {device_id} очищены")        except Exception:            logger.error("Возникла ошибка очистки ресурсов для устройств....")    async def _find_device_by_name(self, target_name: str, timeout: float = DEVICE_DISCOVERY_TIMEOUT):        async with BleakScanner() as scanner:            found_device = None            start_time = time.time()            logger.info(f"Начало поиска устройства {target_name} (таймаут: {timeout}с)")            async for device, advertisement_data in scanner.advertisement_data():                if time.time() - start_time > timeout:                    logger.debug(f"Поиск {target_name} прерван по таймауту")                    break                # Проверка имени устройства                if device.name and device.name == target_name:                    logger.info(f"Устройство {target_name} найдено!")                    found_device = device                    break  # Немедленно выходим при нахождении                # Дополнительная проверка по рекламным данным (если имя может быть в них)                if advertisement_data and advertisement_data.local_name and advertisement_data.local_name == target_name:                    logger.info(f"Устройство {target_name} найдено через advertisement_data!")                    found_device = device                    break            if not found_device:                logger.warning(f"Устройство {target_name} не найдено за {timeout}с")            return found_device    def stop(self):        """ Остановка BLE менеджера """        if not self.is_running:            logger.debug("BLE менеджер не был запущен")            return        # asyncio.create_task(self.disconnect_all_devices())        self.is_running = False        self._work_thread.join(timeout=0.1) # ожидание остановки потока        if self._work_thread.is_alive():            raise ValueError("Поток не остановлен...")        logger.info("BLE менеджер остановлен")    def add_task(self, task: RecordingTaskData):        """ Добавить задачу в очередь """        if not is_bluetooth_enabled():            logger.error("Не включен bluetooth")            msg = (f"Не удалось сделать запись для {task.device.ble_name} в {task.start_time.replace(microsecond=0)}.\n"                   f"Причина: Bluetooth не найден. Убедитесь, что Bluetooth включен.")            self._process_task_failure(task, msg)            self.stop()            return        if not self.is_running:            logger.error("Не запущен BLEManager")            self.start()        logger.info(f"Добавлена задача на запись для {task.device.ble_name}")        self._recording_tasks.append(task)    async def disconnect_all_devices(self):        """ Отключение всех устройств """        devices_id = list(self._connected_devices.keys())        for idx in devices_id:            await self._cleanup_device(idx)    def handle_success_record_result(self, record_data: RecordData):        self.signal_record_result.emit(record_data)    @staticmethod    def set_sampling_rate_in_rat(sampling_rate: int) -> None | int:        """ Установка частоты оцифровки """        if not isinstance(sampling_rate, int):            raise ValueError(f"sampling_rate have type {type(sampling_rate)}, must be int")        if sampling_rate == 500:            return InRatDataRateEcg.HZ_500.value        if sampling_rate == 1000:            return InRatDataRateEcg.HZ_1000.value        if sampling_rate == 2000:            return InRatDataRateEcg.HZ_2000.value        return None    def has_recording_task(self, device_id: UUID) -> bool:        """ Проверка есть ли задача на регистрацию ЭКГ для указанного устройства """        with self._tasks_lock:            # проверка в очереди задач            for task in self._recording_tasks:                if task.device.id == device_id:                    logger.debug(f"Устройство с идентификатором {device_id} в очереди на подключение")                    return True            # проверка в подключенных устройствах            if device_id in self._connected_devices:                logger.debug(f"Устройство с идентификатором {device_id} подключено")                return True            # проверка в активных задачах сбора данных            if device_id in self._acquisition_tasks:                logger.debug(f"С устройства с идентификатором {device_id} идёт регистрация ЭКГ")                return True            # проверка в очереди на подключение            if device_id in self._pending_connections:                logger.debug(f"К устройству с идентификатором {device_id} идёт подключение")                return True        logger.debug(f"Отсутствует устройство с идентификатором {device_id} в очереди задач")        return False